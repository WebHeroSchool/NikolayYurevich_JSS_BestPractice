### JavaScript Best Style Guide NY(c)

#### __1. Объявление переменных__
В JavaScript теперь есть два дополнительных способа объявления переменных: _**let**_ и _**const**_.
_**let**_ является преемником _**var**_. Хотя _**var**_ все еще доступен, _**let**_ ограничивает
область переменных в блоке (а не в функции), в котором они объявлены,
что снижает вероятность ошибки:
```javascript
    //bad
    for (var i = 1; i < 5; i++) {
      console.log(i);
    }
    //<-- logs the numbers 1 to 4
    console.log(i);
    //<-- 5 (variable i still exists outside the loop)
    
    //good
    for (let j = 1; j < 5; j++) {
      console.log(j);
    }
    console.log(j);
    //<-- 'Uncaught ReferenceError: j is not defined'
```
#### __2. Стрелочные функции__
Стрелочные функции делают синтаксис лаконичным и устраняют некоторые трудности с ним. Отдавайте предпочтение стрелочным функциям, вместо ключевого слова _**function**_, особенно для вложенных функций.
```javascript
    //bad
    var add = function(a, b) {
      return a + b;
    }
    //good
    const add = (a, b) => a + b;
```
#### __3. Улучшенный синтаксис класса__
Если вы поклонник объектно-ориентированного программирования, вам может понравиться добавление
классы к языку поверх существующего механизма на основе прототипов.
Хотя это в основном синтаксический сахар, он обеспечивает более понятный синтаксис для разработчиков.
пытаясь подражать классической объектной ориентации с помощью прототипов.
```javascript
    class Person {
      constructor(name) {
        this.name = name;
      }
    greet() {
      console.log(`Hello, my name is ${this.name}`);
      }
    }
```
#### __4. Promises/Асинхронные функции__
Асинхронный характер JavaScript уже давно представляет собой проблему; любой
нетривиальное приложение рискует попасть в 'ад' обратных вызовов при работе с
такие вещи, как запросы Ajax.
К счастью, в ES2015 добавлена встроенная поддержка promises. Promise представляют
значения, которые не существуют на момент вычисления, но могут быть
доступны позже, что делает управление вызовами асинхронных функций более
управляемым, не вдаваясь в глубоко вложенные обратные вызовы.
ES2017 представил асинхронные функции (иногда называемые async / await), которые
вносить улучшения в этой области, позволяя рассматривать асинхронный код, как если бы он
были синхронными:
```javascript
    async function doAsyncOp () {
    var val = await asynchronousOperation();    
    console.log(val);
    return val;
};

```
#### __5. Имена констант должны быть ЗАГЛАВНЫМИ_БУКВАМИ и через нижнее подчёркивание__
Для неизменных величин — НЕИЗМЕННО_ПРАВИЛО: всё заглавными, а слова через подчёркивание.
Если вы абсолютно уверены, что переменная не должна изменяться, вы можете указать ее, написав имя константы. Это подчёркивает неизменность константы, во всём коде.
```javascript
    //bad
    const number = 5;

    //good
    const NUMBER = 5;
```
#### __6. Не используйте eval()__
Не используйте eval или функцию (…string) конструктор (кроме загрузчиков кода). Эти функции потенциально опасны и просто не работают в средах CSP.
На [страничке MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval) для eval() даже есть пометка — “Don’t use eval!”
```javascript
    //bad
    let obj = { a : 20, b : 30};
    let propName = getPropName(); \\return "a" or "b"
    eval('var result = obj.' + propName);

    //good
    let obj = { a : 20, b : 30};
    let propName = getPropName(); \\return "a" or "b"
    let result = obj [propName];
```
#### __7. Объекты__
Для создания объекта используйте фигурные скобки. Не создавайте объекты через конструктор new Object.
```javascript
    //bad
    var item = new Object();
    //good
    var item = {};
```
#### __8. Используйте "===" Сравнение__
Когда вы используете "==", ваши переменные будут преобразованы в типы соответствия.
Оператор "===" вызывает сравнение значений и типов.
```javascript
    //bad
    0 == ""; // true
    //good
    0 === ""; // false
```
#### __9. Использовать значения параметров по умолчанию__
Когда вы вызываете функцию и забываете передать ей параметр, для отсутствующего аргумента устанавливается значение undefined.
```javascript
    //bad
    function logNumber(num) {      
      console.log(num);
    }
    logNumber();
    
    //good
    function logNumber(num = 25) {
      console.log(num);
    }
    logNumber();
```
#### __10. Завершите Switches настройками по умолчанию__
Рекомендуется заканчивать операторы switch значением по умолчанию. Даже если так не кажется.
```javascript
    switch(type)
    {
      case 1:
        //something
      case 2:
        //something else
      default:
        // unknown type! 
        // there should probably be some error-handling
        // here, maybe an exception
}
```
